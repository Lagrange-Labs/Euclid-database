use anyhow::Result;
use circuit::{revelation_num_io, BuilderParams, RevelationRecursiveWires};
use recursion_framework::{
    circuit_builder::{CircuitWithUniversalVerifier, CircuitWithUniversalVerifierBuilder},
    framework::RecursiveCircuits,
};
use serde::{Deserialize, Serialize};

use plonky2::{
    hash::poseidon::PoseidonHash,
    iop::target::Target,
    plonk::{
        circuit_data::{CircuitData, VerifierCircuitData, VerifierOnlyCircuitData},
        config::Hasher,
        proof::ProofWithPublicInputs,
    },
};

use crate::{
    api::{
        default_config, deserialize_proof, ProofWithVK, C, D, F,
        QUERY_CIRCUIT_SET_SIZE,
    },
    block::NUM_IVC_PUBLIC_INPUTS,
    query_erc20::block,
};

pub use self::circuit::{RevelationCircuit, RevelationRecursiveInput};

pub mod circuit;
mod public_inputs;
pub use self::public_inputs::RevelationPublicInputs;
/// Wires containing the main logic wires of the RevelationCircuit,
/// the verifier wires to check a crate::block proof (block db) and
/// the verifier wires to check a proof from query2/block circuit set.
/// The two const parameters are:
/// - `BLOCK_DB_DEPTH` the depth of the block db merkle tree, fixed since we
///   we use a fixed sparse merkle tree.
/// - `L` the number of NFT IDs to reveal
#[derive(Serialize, Deserialize)]
pub struct Parameters<const BLOCK_DB_DEPTH: usize, const L: usize> {
    revelation_circuit:
        CircuitWithUniversalVerifier<F, C, D, 0, RevelationRecursiveWires<BLOCK_DB_DEPTH, L>>,
}

/// Circuit inputs for the revelation step which contains the
/// raw witnesses and the proof to verify in circuit.
/// The proof is any of the proofs contained in the `query2/block/` module.
pub struct RevelationErcInput<const L: usize> {
    /// values expected by the RevelationCircuit main logic
    logic_inputs: RevelationCircuit<L>,
    /// The actual proof generated by query2/block module, the top one
    query_block_proof: ProofWithVK,
    /// The actual proof generated by the block db module, each time a new block
    /// is preprocessed
    block_db_proof: ProofWithPublicInputs<F, C, D>,
}

impl<const L: usize> RevelationErcInput<L> {
    pub fn new(
        query_min_block: usize,
        query_max_block: usize,
        query_block_proof: Vec<u8>,
        block_db_proof: Vec<u8>,
    ) -> Result<RevelationErcInput<L>> {
        let main_inputs = RevelationCircuit {
            query_min_block_number: query_min_block,
            query_max_block_number: query_max_block,
        };
        Ok(RevelationErcInput {
            logic_inputs: main_inputs,
            query_block_proof: ProofWithVK::deserialize(&query_block_proof)?,
            block_db_proof: deserialize_proof(&block_db_proof)?,
        })
    }
}

const QUERY_ERC_BLOCK_NUM_IO: usize = block::BlockPublicInputs::<Target>::total_len();
const BLOCK_DB_NUM_IO: usize = NUM_IVC_PUBLIC_INPUTS;
pub(crate) const fn num_io<const L: usize>() -> usize {
    revelation_num_io::<L>() + 1
}

impl<const BLOCK_DB_DEPTH: usize, const L: usize> Parameters<BLOCK_DB_DEPTH, L>
where
    [(); <PoseidonHash as Hasher<F>>::HASH_SIZE]:,
    [(); num_io::<L>()]:,
{
    /// Arguments are the circuit sets used to generate the query2/block proofs
    /// and the block db proof, and the verification key of the block db circuit
    pub fn build(
        query2_block_set: &RecursiveCircuits<F, C, D>,
        block_db_circuit_set: &RecursiveCircuits<F, C, D>,
        block_db_verifier_data: &VerifierOnlyCircuitData<C, D>,
    ) -> Self {
        let builder = CircuitWithUniversalVerifierBuilder::<F, D, { num_io::<L>() }>::new::<C>(
            default_config(),
            QUERY_CIRCUIT_SET_SIZE,
        );
        let builder_params = BuilderParams::new(
            query2_block_set.clone(),
            block_db_circuit_set.clone(),
            block_db_verifier_data.clone(),
        );
        let circuit = builder.build_circuit(builder_params);

        Self {
            revelation_circuit: circuit,
        }
    }
    fn generate_proof_internal(
        &self,
        query_circuits: &RecursiveCircuits<F, C, D>,
        inputs: RevelationRecursiveInput<L>,
    ) -> Result<ProofWithPublicInputs<F, C, D>> {
        query_circuits.generate_proof(&self.revelation_circuit, [], [], inputs)
    }

    pub fn generate_proof(
        &self,
        query_circuits: &RecursiveCircuits<F, C, D>,
        inputs: RevelationRecursiveInput<L>,
    ) -> Result<Vec<u8>> {
        let proof = self.generate_proof_internal(query_circuits, inputs)?;
        ProofWithVK::from((proof, self.verifier_data().verifier_only.clone())).serialize()
    }
    pub fn circuit_data(&self) -> &CircuitData<F, C, D> {
        self.revelation_circuit.circuit_data()
    }
    pub fn verifier_data(&self) -> VerifierCircuitData<F, C, D> {
        self.revelation_circuit.circuit_data().verifier_data()
    }
    pub fn verify_proof(&self, proof: Vec<u8>) -> Result<()> {
        let proof = deserialize_proof(&proof)?;
        self.revelation_circuit.circuit_data().verify(proof)
    }
}

#[cfg(test)]
mod test {
    use std::iter::once;

    use crate::{
        api::{serialize_proof, ProofWithVK},
        block::empty_merkle_root,
        keccak::PACKED_HASH_LEN,
        query_erc20::revelation::{RevelationRecursiveInput, QUERY_ERC_BLOCK_NUM_IO},
        utils::{Packer, ToFields},
    };
    use anyhow::Result;
    use ethers::types::Address;
    use itertools::Itertools;
    use mrp2_utils::types::PACKED_U256_LEN;
    use plonky2::{
        field::{
            goldilocks_field::GoldilocksField,
            types::{Field, PrimeField64, Sample},
        },
        hash::hash_types::{HashOut, NUM_HASH_OUT_ELTS},
    };
    use rand::{thread_rng, Rng};
    use recursion_framework::framework_testing::TestingRecursiveCircuits;
    use serial_test::serial;

    use super::*;

    use crate::block::PublicInputs as BlockDbPublicInputs;

    use crate::{
        api::{C, D, F},
        query_erc20::block::BlockPublicInputs,
    };

    #[test]
    #[serial]
    fn test_revelation_api_erc20() -> Result<()> {
        // Generate a fake query2/block circuit set
        let query2_testing_framework =
            TestingRecursiveCircuits::<F, C, D, QUERY_ERC_BLOCK_NUM_IO>::default();
        let query2_block_circuit_set = query2_testing_framework.get_recursive_circuit_set();

        // Generate a fake block/ verification key
        let block_db_testing_framework =
            TestingRecursiveCircuits::<F, C, D, BLOCK_DB_NUM_IO>::default();
        let block_db_circuit_set = block_db_testing_framework.get_recursive_circuit_set();

        // Generate a fake query circuits verification key
        let queries_testing_framework =
            TestingRecursiveCircuits::<F, C, D, { num_io::<L>() }>::default();
        let queries_circuit_set = queries_testing_framework.get_recursive_circuit_set();

        let block_db_vk = block_db_testing_framework.verifier_data_for_input_proofs::<1>()[0];
        // Build the params
        const L: usize = 5;
        const BLOCK_DB_DEPTH: usize = 2;
        let params = super::Parameters::<BLOCK_DB_DEPTH, L>::build(
            query2_block_circuit_set,
            block_db_circuit_set,
            block_db_vk,
        );

        // Generate a fake block db proof
        let init_root = empty_merkle_root::<GoldilocksField, 2, BLOCK_DB_DEPTH>();
        let last_root = HashOut {
            elements: F::rand_vec(NUM_HASH_OUT_ELTS).try_into().unwrap(),
        };
        let init_block_number = F::from_canonical_u32(thread_rng().gen::<u32>());
        let db_range = 555;
        let last_block_number = init_block_number + F::from_canonical_usize(db_range);
        let last_block_hash = F::rand_vec(PACKED_HASH_LEN);

        let block_db_inputs: [F; BLOCK_DB_NUM_IO] = BlockDbPublicInputs::from_parts(
            &init_root.elements,
            &last_root.elements,
            init_block_number,
            last_block_number,
            &last_block_hash.try_into().unwrap(),
        )
        .into_iter()
        .chain(once(F::ONE))
        .collect_vec()
        .try_into()
        .unwrap();
        let block_db_pi = BlockDbPublicInputs::<GoldilocksField>::from(&block_db_inputs);
        let block_db_proof =
            &block_db_testing_framework.generate_input_proofs::<1>([block_db_inputs.clone()])?[0];

        // Generate a fake query2/block proof, taking some inputs from the block db
        // block range asked is just one block less than latest block in db
        // note these are the range the proofs would have computed. These needs
        // to be checked against the range of the query and make sure they match,
        // that's the purpose of the revelation circuit.
        let query_max_number = block_db_pi.block_number_data() - F::ONE;
        let query_range = F::from_canonical_usize(50);
        let query_min_number = query_max_number - query_range;
        let query_root = HashOut {
            elements: block_db_pi.root_data().try_into().unwrap(),
        };
        let smc_address = Address::random();
        let user_address = Address::random();
        let mapping_slot = F::rand();
        let length_slot = F::rand();
        let rewards_rate = [F::ZERO; PACKED_U256_LEN];
        let query_results = [F::ZERO; PACKED_U256_LEN];
        let pis = BlockPublicInputs::from_parts(
            query_max_number,
            query_range,
            query_root,
            &smc_address
                .as_fixed_bytes()
                .pack()
                .to_fields()
                .try_into()
                .unwrap(),
            &user_address
                .as_fixed_bytes()
                .pack()
                .to_fields()
                .try_into()
                .unwrap(),
            mapping_slot,
            length_slot,
            &query_results,
            &rewards_rate,
        );
        let query2_block_proof = query2_testing_framework
            .generate_input_proofs([pis])
            .unwrap();
        let query2_block_vd = query2_testing_framework.verifier_data_for_input_proofs::<1>();

        let q2_proof_buff = ProofWithVK {
            proof: query2_block_proof[0].clone(),
            vk: query2_block_vd[0].clone(),
        }
        .serialize()?;
        let block_db_buff = serialize_proof(block_db_proof)?;
        let revelation_inputs = RevelationRecursiveInput::new(
            RevelationErcInput::new(
                // we set on purpose that the query parameters and the range we computed
                // are the same, as they should be since we have to look at all the blocks
                query_min_number.to_canonical_u64() as usize,
                query_max_number.to_canonical_u64() as usize,
                q2_proof_buff,
                block_db_buff,
            )?,
            query2_block_circuit_set.clone(),
        )?;
        println!("generating revelation proof");
        let proof = params.generate_proof(queries_circuit_set, revelation_inputs)?;
        params.verify_proof(proof)?;
        Ok(())
    }
}
