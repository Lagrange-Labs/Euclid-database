use crate::{
    api::{default_config, deserialize_proof, ProofWithVK, C, D, F, QUERY_CIRCUIT_SET_SIZE},
    block::NUM_IVC_PUBLIC_INPUTS,
    eth::left_pad32,
    query2::block,
    types::PACKED_MAPPING_KEY_LEN,
    utils::Packer,
};
use anyhow::Result;
use circuit::{
    revelation_num_io, BuilderParams, RevelationRecursiveInput, RevelationRecursiveWires,
};
use plonky2::{
    hash::poseidon::PoseidonHash,
    iop::target::Target,
    plonk::{
        circuit_data::{CircuitData, VerifierCircuitData, VerifierOnlyCircuitData},
        config::Hasher,
        proof::ProofWithPublicInputs,
    },
};
use recursion_framework::{
    circuit_builder::{CircuitWithUniversalVerifier, CircuitWithUniversalVerifierBuilder},
    framework::RecursiveCircuits,
};
use serde::{Deserialize, Serialize};
use std::{array::from_fn as create_array, collections::BTreeMap};

pub use self::circuit::RevelationCircuit;

pub mod circuit;
mod public_inputs;
pub use self::public_inputs::RevelationPublicInputs;
/// Wires containing the main logic wires of the RevelationCircuit,
/// the verifier wires to check a crate::block proof (block db) and
/// the verifier wires to check a proof from query2/block circuit set.
/// The two const parameters are:
/// - `BLOCK_DB_DEPTH` the depth of the block db merkle tree, fixed since we
///   we use a fixed sparse merkle tree.
/// - `L` the number of NFT IDs to reveal
#[derive(Serialize, Deserialize)]
pub struct Parameters<const BLOCK_DB_DEPTH: usize, const L: usize> {
    revelation_circuit:
        CircuitWithUniversalVerifier<F, C, D, 0, RevelationRecursiveWires<BLOCK_DB_DEPTH, L>>,
}

/// Circuit inputs for the revelation step which contains the
/// raw witnesses and the proof to verify in circuit.
/// The proof is any of the proofs contained in the `query2/block/` module.
pub struct RevelationInput<const L: usize> {
    /// values expected by the RevelationCircuit main logic
    logic_inputs: RevelationCircuit<L>,
    /// The actual proof generated by query2/block module, the top one
    query_block_proof: ProofWithVK,
    /// The actual proof generated by the block db module, each time a new block
    /// is preprocessed
    block_db_proof: ProofWithPublicInputs<F, C, D>,
}

impl<const L: usize> RevelationInput<L> {
    pub fn new(
        mapping_keys: Vec<Vec<u8>>,
        query_min_block: usize,
        query_max_block: usize,
        query2_block_proof: Vec<u8>,
        block_db_proof: Vec<u8>,
    ) -> Result<Self> {
        // sort mapping keys depending on the last limb, as it is the only limb currently considered
        // in the circuit
        let sorted_keys = mapping_keys
            .iter()
            .map(|key| {
                let packed = left_pad32(key).pack();
                (*packed.last().unwrap(), packed)
            })
            .collect::<BTreeMap<_, _>>();
        let mut sorted_keys_iter = sorted_keys.into_iter();
        let keys = create_array(|_i| {
            if let Some((_, packed)) = sorted_keys_iter.next() {
                create_array(|j| packed[j])
            } else {
                [0u32; PACKED_MAPPING_KEY_LEN]
            }
        });
        let num_entries = mapping_keys.len();
        assert!(
            num_entries <= L,
            "Number of entries {} should not exceed fixed parameter L {}",
            num_entries,
            L
        );
        let main_inputs = RevelationCircuit {
            packed_keys: keys,
            num_entries: num_entries as u8,
            query_min_block_number: query_min_block,
            query_max_block_number: query_max_block,
        };
        Ok(Self {
            logic_inputs: main_inputs,
            query_block_proof: ProofWithVK::deserialize(&query2_block_proof)?,
            block_db_proof: deserialize_proof(&block_db_proof)?,
        })
    }
}

const QUERY2_BLOCK_NUM_IO: usize = block::BlockPublicInputs::<Target>::total_len();
const BLOCK_DB_NUM_IO: usize = NUM_IVC_PUBLIC_INPUTS;
pub(crate) const fn num_io<const L: usize>() -> usize {
    revelation_num_io::<L>() + 1
}

impl<const BLOCK_DB_DEPTH: usize, const L: usize> Parameters<BLOCK_DB_DEPTH, L>
where
    [(); <PoseidonHash as Hasher<F>>::HASH_SIZE]:,
    [(); num_io::<L>()]:,
{
    /// Arguments are the circuit sets used to generate the query2/block proofs
    /// and the block db proof, and the verification key of the block db circuit
    pub fn build(
        query2_block_set: &RecursiveCircuits<F, C, D>,
        block_db_circuit_set: &RecursiveCircuits<F, C, D>,
        block_db_verifier_data: &VerifierOnlyCircuitData<C, D>,
    ) -> Self
    where
        [(); <PoseidonHash as Hasher<F>>::HASH_SIZE]:,
    {
        let builder = CircuitWithUniversalVerifierBuilder::<F, D, { num_io::<L>() }>::new::<C>(
            default_config(),
            QUERY_CIRCUIT_SET_SIZE,
        );
        let builder_params = BuilderParams::new(
            query2_block_set.clone(),
            block_db_circuit_set.clone(),
            block_db_verifier_data.clone(),
        );
        let circuit = builder.build_circuit(builder_params);

        Self {
            revelation_circuit: circuit,
        }
    }
    fn generate_proof_internal(
        &self,
        query_circuits: &RecursiveCircuits<F, C, D>,
        inputs: RevelationRecursiveInput<L>,
    ) -> Result<ProofWithPublicInputs<F, C, D>> {
        query_circuits.generate_proof(&self.revelation_circuit, [], [], inputs)
    }
    pub fn generate_proof(
        &self,
        query_circuits: &RecursiveCircuits<F, C, D>,
        inputs: RevelationRecursiveInput<L>,
    ) -> Result<Vec<u8>> {
        let proof = self.generate_proof_internal(query_circuits, inputs)?;
        ProofWithVK::from((proof, self.verifier_data().verifier_only.clone())).serialize()
    }
    pub fn circuit_data(&self) -> &CircuitData<F, C, D> {
        self.revelation_circuit.circuit_data()
    }
    pub fn verifier_data(&self) -> VerifierCircuitData<F, C, D> {
        self.revelation_circuit.circuit_data().verifier_data()
    }
    pub fn verify_proof(&self, proof: Vec<u8>) -> Result<()> {
        let proof = deserialize_proof(&proof)?;
        self.revelation_circuit.circuit_data().verify(proof)
    }
}

#[cfg(test)]
mod test {
    use std::iter::once;

    use crate::{
        api::{serialize_proof, ProofWithVK},
        block::{empty_merkle_root, PublicInputs as BlockDbPublicInputs},
        eth::left_pad,
        keccak::PACKED_HASH_LEN,
        query2::revelation::{RevelationRecursiveInput, QUERY2_BLOCK_NUM_IO},
        types::MAPPING_KEY_LEN,
        utils::{Packer, ToFields},
    };
    use anyhow::Result;
    use ethers::types::Address;
    use itertools::Itertools;
    use plonky2::{
        field::{
            goldilocks_field::GoldilocksField,
            types::{Field, PrimeField64, Sample},
        },
        hash::hash_types::{HashOut, NUM_HASH_OUT_ELTS},
    };
    use rand::{thread_rng, Rng};
    use recursion_framework::framework_testing::TestingRecursiveCircuits;
    use serial_test::serial;

    use super::*;

    use crate::{
        api::{C, D, F},
        eth::left_pad32,
        group_hashing,
        query2::block::BlockPublicInputs,
    };

    #[test]
    #[serial]
    fn test_revelation_api() -> Result<()> {
        // Generate a fake query2/block circuit set
        let query2_testing_framework =
            TestingRecursiveCircuits::<F, C, D, QUERY2_BLOCK_NUM_IO>::default();
        let query2_block_circuit_set = query2_testing_framework.get_recursive_circuit_set();

        // Generate a fake block/ verification key
        let block_db_testing_framework =
            TestingRecursiveCircuits::<F, C, D, BLOCK_DB_NUM_IO>::default();
        let block_db_circuit_set = block_db_testing_framework.get_recursive_circuit_set();

        // Generate a fake query circuits verification key
        let queries_testing_framework =
            TestingRecursiveCircuits::<F, C, D, { num_io::<L>() }>::default();
        let queries_circuit_set = queries_testing_framework.get_recursive_circuit_set();

        let block_db_vk = block_db_testing_framework.verifier_data_for_input_proofs::<1>()[0];
        // Build the params
        const L: usize = 2;
        const BLOCK_DB_DEPTH: usize = 2;
        let params = super::Parameters::<BLOCK_DB_DEPTH, L>::build(
            query2_block_circuit_set,
            block_db_circuit_set,
            block_db_vk,
        );

        // Generate a fake block db proof
        let init_root = empty_merkle_root::<GoldilocksField, 2, BLOCK_DB_DEPTH>();
        let last_root = HashOut {
            elements: F::rand_vec(NUM_HASH_OUT_ELTS).try_into().unwrap(),
        };
        let init_block_number = F::from_canonical_u32(thread_rng().gen::<u32>());
        let db_range = 555;
        let last_block_number = init_block_number + F::from_canonical_usize(db_range);
        let last_block_hash = F::rand_vec(PACKED_HASH_LEN);

        let block_db_inputs: [F; BLOCK_DB_NUM_IO] = BlockDbPublicInputs::from_parts(
            &init_root.elements,
            &last_root.elements,
            init_block_number,
            last_block_number,
            &last_block_hash.try_into().unwrap(),
        )
        .into_iter()
        .chain(once(F::ONE))
        .collect_vec()
        .try_into()
        .unwrap();
        let block_db_pi = BlockDbPublicInputs::<GoldilocksField>::from(&block_db_inputs);
        let block_db_proof =
            &block_db_testing_framework.generate_input_proofs::<1>([block_db_inputs.clone()])?[0];

        // Generate a fake query2/block proof, taking some inputs from the block db
        // block range asked is just one block less than latest block in db
        let query_max_number = block_db_pi.block_number_data() - F::ONE;
        let query_range = F::from_canonical_usize(10);
        let query_min_number = query_max_number - query_range + F::ONE;
        let query_root = HashOut {
            elements: block_db_pi.root_data().try_into().unwrap(),
        };
        let smc_address = Address::random();
        let user_address = Address::random();
        let mapping_slot = F::rand();
        let length_slot = F::rand();
        let mapping_keys = (0..L)
            .map(|_| left_pad::<MAPPING_KEY_LEN>(&[thread_rng().gen::<u8>()]))
            .collect::<Vec<_>>();
        let packed_field_mks = mapping_keys
            .iter()
            .map(|x| x.pack().to_fields())
            .collect::<Vec<_>>();
        let digests = packed_field_mks
            .iter()
            .map(|i| group_hashing::map_to_curve_point(i))
            .collect::<Vec<_>>();
        let single_digest = group_hashing::add_curve_point(&digests);
        let pis = BlockPublicInputs::from_parts(
            query_max_number,
            query_range,
            query_root,
            &smc_address
                .as_fixed_bytes()
                .pack()
                .to_fields()
                .try_into()
                .unwrap(),
            &left_pad32(user_address.as_fixed_bytes())
                .pack()
                .to_fields()
                .try_into()
                .unwrap(),
            mapping_slot,
            length_slot,
            single_digest.to_weierstrass(),
        );
        let query2_block_proof = query2_testing_framework
            .generate_input_proofs([pis])
            .unwrap();
        let query2_block_vd = query2_testing_framework.verifier_data_for_input_proofs::<1>();

        let q2_proof_buff = ProofWithVK {
            proof: query2_block_proof[0].clone(),
            vk: query2_block_vd[0].clone(),
        }
        .serialize()?;
        let block_db_buff = serialize_proof(block_db_proof)?;
        let revelation_inputs = RevelationRecursiveInput::new(
            RevelationInput::new(
                mapping_keys.into_iter().map(|x| x.to_vec()).collect(),
                query_min_number.to_canonical_u64() as usize,
                query_max_number.to_canonical_u64() as usize,
                q2_proof_buff,
                block_db_buff,
            )?,
            query2_block_circuit_set.clone(),
        )?;
        println!("generating revelation proof");
        let proof = params.generate_proof(queries_circuit_set, revelation_inputs)?;
        params.verify_proof(proof)?;
        Ok(())
    }
}
